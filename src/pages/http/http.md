# HTTP

- 목차
    1. http
        1. 무상태 프로토콜(stateless)
        2. 비연결성
        3. HTTP 메세지
    2. HTTP 메서드 속성
        1. 안전
        2. 멱등(Idempotent)
        3. 캐시 가능(Cacheable)



## http

- HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
- HTTP/1.0 1996년: 메서드, 헤더 추가
- HTTP/1.1 1997년: 가장 많이 사용하며 우리에게 가장 중요한 버전
    - RFC2068 (1997) -> RFC2616 (1999) -> RFC7230 ~ 7235 (2014)
- HTTP/2 2015년: 성능 개선
- HTTP/3 진행중: TCP 대신에 UD 사용, 성능 개선

TCP: HTTP/1.1, HTTP/2
UDP: HTTP/3
현재 HTTP/1.1을 주로 사용하며 HTTP/2와 HTTP/3도 점점 증가하는 추세이다.

지금 우리가 사용하는 HTTP 버전을 확인해보자.

우선 개발자 도구를 켜고 네트워크 탭으로 이동한다.

우클릭을 통해 '프로토콜' 항목을 활성화 한다.

![](https://velog.velcdn.com/images/deonii/post/b8b67d2b-a744-4de9-8967-7312f6ecd715/image.png)

위의 캡쳐는 해당 블로그에서 확인한 로그이다.

HTTP/1.1로 요청을 주고 받는 모습을 알 수 있다.

HTTP의 특징으로 아래 4가지를 뽑을수 있다.

- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단숨함, 확장 가능

### 무상태 프로토콜(stateless)

서버가 클라이언트의 상태를 보존하지 않는다는 의미이다.

장점: 서버 확장성 높음

단점: 클라이언트가 추가 데이터 전송

장단점이 확실하지만 실무적인 한계 또한 존재한다.

상태 유지가 필요한 경우(ex: 로그인)가 존재한다.

때문에 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지를 최소한으로만 한다.

### 비연결성

서버에 연결을 계속 유지할 경우 서버 자원을 소모한다는 단점이 있다.

때문에 최소한의 자원을 사용해서 통신이 가능하다.

HTTP는 기본이 연결을 유지하지 않는 모델이다.

일반적으로 초 단위의 이하의 빠른 속도로 응답한다.

만약 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다.

서버의 자원을 효율적으로 사용할 수 있다는 장점이 있지만 단점도 존재한다.

TCP/IP 연결을 매 통신마다 새로 연결해야한다. -> 통신마다 3 way handshake 시간이 추가된다.

웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JS, css, 추가 이미지 등등 수 많은 자원이 함께 다운로드 된다.

지금은 HTTP 지속 연결(Persistent Connections)로 문제를 해결했다.

HTTP/2, HTTP/3에서는 더 많은 최적화가 이루어졌다.

### HTTP 메세지

HTTP 메세지를 통해 거의 모든 형태의 데이터를 전송 가능하다.(Text, 이미지, 음성, 영상, 파일, json, xml 등)

시작 라인(start-line), 헤더, 공백 라인(CRLF), 메세지 바디로 구성되어있다.

시작 라인에는 메서드, 요청 대상(절대 경로), HTTP 버전이 들어간다.

헤더는 HTTP 전송에 필요한 모든 부가정보가 들어있다.(ex: 메세지 바디의 내용, 메세지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보 등)

표준 헤어가 너무 많고 필요시 임의의 헤더 추가가 가능하다.

메세지 바디는 실제 전송할 데이터가 들어있다.

html 문서, 이미지, 영상, json 등등 byte로 표현 가능한 모든 데이터가 전송가능하다.

## HTTP 메서드 속성

![](https://velog.velcdn.com/images/deonii/post/bf6d78ba-ac03-433c-a5e5-6205cce9f55f/image.png)

위의 표에서 3가지 키워드에 대해서 정리해보자.

### 안전

호출해도 리소스를 변경하지 않는다.

GET이 여기에 해당한다.

하지만 GET 요청을 계속 보내게되서 로그가 쌓여서 장애가 생길수도 있지 않겠냐? 라는 의문이 생길 수도 있다.

안전에서는 해당 리소스에 대한것만 고려한다.

### 멱등(Idempotent)

한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.

GET: 여러번 조회해도 같은 결과가 조회된다.

PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.

DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.

POST: 멱등이 아니다. 결제를 예시로 생각하면 두 번 호출하면 같은 결제가 두번 생성된다.

멱등은 도대체 왜 식별해야 할까?

자동 복구 메커니즘 때문이다.

서버가 타임아웃 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단하는 근거가 된다.

예시로 GET요청이 응답이 없을때 다시 요청을 보내는것이 괜찮은가? 멱등을 확인해보니 가능하다 한다. 보내도 된다.

POST요청이 응답이 없다. 다시 보내도 괜찮을까? 멱등을 확인해보니 불가능하다. 보내면 안된다.

### 캐시 가능(Cacheable)

응답 결과 리소스를 캐시해서 사용해도 되는가?에 해당한다.

GET, HEAD, POST, PATCH 캐시가 가능하다.

하지만 실제로는 GET, HEAD 정도만 캐시로 사용한다.

