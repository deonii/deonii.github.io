# 프로세스 / 쓰레드

- 목차
    1. 프로세스(Process)
        1. 컴파일 과정(C언어 기준)
        2. CPU관점
        3. 유니프로그래밍
        4. 멀티프로그래밍
        5. 멀티프로세싱
    2. PCB(Process Control Block)
        1. 포인터
        2. 프로세스 상태
        3. 프로세스 ID
        4. 프로그램 카운터
        5. 레지스터 정보
        6. 메모리 관련 정보
        7. CPU 스케줄링 정보
    3. 컨텍스트 스위칭(Context Switching)
    4. 프로세스 생성과 종료
    5. 쓰레드

## 프로세스(Process)

> 간단한 정의: 하드디스크에서 메모리로 올라가 실행 중인 프로그램.

프로세스에는 코드, 데이터, 힙, 스택 영역이 존재한다.

코드 영역은 자신을 실행하는 코드가 저장되어 있다.

데이터 영역은 전역 변수와 Static(정적) 변수가 저장되어 있다.

스택 영역에는 지역 변수와 함수를 호출 했을 때 필요한 정보들이 저장된다.

힙 영역은 프로그래머가 동적으로 메모리를 할당하는 데에 사용된다.
(C언어에서 malloc()(힙영역에 메모리 공간 할당), free()(할당된 메모리 공간해제)를 호출하면 힙 영역에 자원을 할당/해제 가능하다)

작성된 프로그램이 메모리에 올라가 프로세스가 되는 과정을 간단하게 알아보자.

### 컴파일 과정(C언어 기준)

C언어는 컴파일 언어이기 때문에 컴파일을 해줘야 한다.

- 전처리기
    1. 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러온다.
    2. 전처리기를 거치면 파일의 확장자는 .i가 된다.
- 컴파일러
    1. 컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔준다.
    2. 어셈블리어는 명령어가 기계어와 일대일 매칭이 되기 때문에 기계어와 가장 가까운 언어이다.
    3. 컴파일을 거치면 파일의 확장자는 .s가 된다.
- 어셈블러
    1. 어셈블리어를 기계어로 바꿔준다.
    2. 파일의 내용은 0과 1로 이루어진 기계어로 구성되고 파일의 확장자는 .o가 된다.
    3. 기계어로 구성되어 있기 때문에 텍스트 에디터로 열어보면 글씨가 깨져서 보인다.
- 링커
    1. 링킹을 진행함. 여러가지 라이브러리나 다른 소스코드를 연결한다.
    2. 링킹을 거치면 파일의 확장자는 .exe가 된다.

### CPU 관점

아래 작성된 프로그램이 어떻게 작동하는지 CPU 관점에서 살펴보자.

```
int num1 = 5;
int num2 = 7;
int result = num1 + num2;
```

CPU내 제어장치가 숫자5와 7을 메모리에 저장시킨다.

메모리에 저장된 값을 edx, eax 레지스터로 가져온다.

제어장치가 레지스터에 저장된 5와7을 가지고 더하라는 명령을 하면 산술논리 연산장치가 두 숫자를 더하고 그 결과는 eax 레지스터에 저장된다.

다시 제어장치가 eax 레지스터에 저장된 12를 가져와서 메모리에 저장시킨다.

### 유니프로그래밍

메모리에 오직 하나의 프로세스가 올라온 것을 말한다.

### 멀티프로그래밍

유니프로그래밍과 반대로 메모리에 여러개의 프로세스가 올라온 것을 말한다.

### 멀티프로세싱

유니프로그래밍과 멀티프로그래밍을 메모리 관점으로 정의한 것이라면 멀티프로세싱은 CPU 관점으로 정의한 것이다.

멀티프로세싱은 CPU가 여러개의 프로세스를 처리하는 것을 말한다.

## PCB(Process Control Block)

프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고있는 PCB를 만들고 저장한다.

PCB들은 연결리스트라는 자료구조로 저장된다.

운영체제는 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB를 제거한다.

아래부터는 PCB를 구성하는 요소들 중 일부를 정리했다.

### 포인터

부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터 등이 있고 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있다.

### 프로세스 상태

현재 프로세스의 다섯가지 상태(생성, 준비, 실행, 대기, 완료)를 나타낸다.

> 생성 : PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태이다. 메모리에 프로그램 적재를 승인받으면 준비상태로 넘어간다.

> 준비 : CPU를 사용하기 위해 기다리고 있는 상태이다. CPU 스케쥴러에 의해 CPU가 할당된다. 대부분의 프로세스는 준비상태에 있다.

> 실행 : 준비 상태의 프로세스가 CPU 스케쥴러에 의해 CPU를 할당받아 실행되는 상태이다. 실행상태에 있는 프로세스의 수는 CPU의 개수만큼 이다.
> 프로세스는 무한정 CPU를 사용하는 것이 아니라 부여된 시간만큼만 사용할 수 있다. 부여된 시간이 지나면 CPU 스케쥴러가 할당된 CPU를 강제로 뺏는다.
> 이때 프로세스는 다시 준비상태가 된다.

> 대기 : 프로세스가 입출력을 요청하면 입출력을 완료될 때 까지 기다리는 상태이다. CPU는 굉장히 빠른장치인데 사람의 입출력을 기다리는것은 굉장히 큰 손해이다.
> 때문에 입출력을 기다리는 프로세스는 대기상태로 변경하고 CPU를 다른 프로세스를 할당한다.

> 완료 : 프로세스가 종료된 상태이다. 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거한다.

### 프로세스 ID

프로세스를 식별하기 위한 숫자가 저장된다.

### 프로그램 카운터

다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장한다.

오늘날 OS는 시분할처리로 여러 프로세스를 짧은 시간동안 번갈아 실행한다.

때문에 어떤 프로세스가 실행되다가 다른 프로세스에 CPU를 뺏긴후 다시 실행될 때 원래 실행하던 명령어가 실행되어야 하기때문에 반드시 필요하다.

### 레지스터 정보

프로세스가 실행될 때 사용했던 레지스터 값들이 저장된다.

프로그램 카운터와 마찬가지로 CPU를 뺏기고 다시 시작할 때 사용하던 값을 복구하기 위한 용도이다.

### 메모리 관련 정보

프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기위한 경계레지스터 값 등이 저장된다.

### CPU 스케줄링 정보

CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간등이 저장된다.

## 컨텍스트 스위칭(Context Switching)

컨텍스트 스위칭은 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업이다.

컨텍스트 스위칭이 일어날때 PCB의 내용이 변경된다.

실행중인 프로세스의 작업내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅됩니다.

컨텍스트 스위칭이 일어날 때 PCB에 변경되는 값들로는 프로세스 상태, 프로그램 카운터, 각종 레지스터 값이 있다.

아래는 컨텍스트 스위칭을 하는 상황의 예시이다.

프로세스 A의 CPU 점유 시간을 초과해 OS에서 인터럽트를 발생시킨다.

프로세스 A는 하던 작업을 멈추고 현재 CPU의 레지스터 값 등을 PCB A에 저장한다.

프로세스 B를 실행하기 위해서 PCB B에 있는 CPU의 레지스터 값을 CPU에 설정한다.(프로그램 카운터를 포함하고 있어 바로 프로세스 B를 실행 가능하다)

컨텍스트 스위칭이 발생하는 이유로 CPU 점유시간이 다되거나, 입출력 요청이 있거나, 다른 종류의 인터럽트가 있을때 발생한다.

## 프로세스 생성과 종료

일반적으로 프로세스가 생성될때는 다음과 같은 과정을 거친다.

프로그램이 실행되면 운영체제는 해당 프로그램의 코드영역과 데이터 영역을 메모리에 로드하고 빈 스택과 빈 힙을 만들어 공간을 확보한다.

이 프로세스를 관리하기 위한 PCB를 만들어 값을 초기화 해준다.

위의 과정은 컴퓨터가 부팅될때 딱 한번 진행되고 이후에는 이 '0번 프로세스'를 복사해서 사용하게 된다.(fork() 함수를 사용한다.)

이렇게 하는 이유는 새로 생성하는 것 보다 복사를 하는게 더 빠르기 때문이다.

이렇게 복사된 프로세스는 자식 프로세스라고 하고 0번 프로세스는 부모 프로세스가 된다.

자식 프로세스는 부모 프로세스의 코드영역, 데이터영역, 스택영역과 PCB의 내용을 전부 복사한다.

이후 exec() 함수를 실행하여 코드와 프로세스 영역을 원하는 값으로 덮어쓴다.

프로세스 사용 후 exit() 함수를 통해 자식 프로세스가 부모 프로세스에게 종료되었다는 것을 알린다.

이때 부모 프로세스가 자식 프로세스보다 먼저 종료되거나 자식 프로세스가 비정상적으로 종료돼 exit()신호를 주지 못해서 Exit status를 읽지 못해 메모리에 계속 살아있는 상태를 "좀비 프로세스"라고 부른다.

컴퓨터를 오래켜두면 느려지는 현상이 발생하곤하는데 여러 프로세스가 메모리에 올라가있는 경우도 잇고 좀비 프로세스가 많아져서 메모리를 차지하는 경우도 있다.

## 쓰레드

운영체제가 작업을 처리하는 단위는 프로세스이다.

쓰레드는 프로세스 내에 존재하는것으로 1개 이상 있을 수 있다.

한 프로세스 내에 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙영역을 공유한다.

스택은 공유하지 않고 쓰레드마다 하나씩 가지고있다.

프로세스 내 쓰레드마다 ID를 부여하고 이를 관리하기 위한 TCB(Thread Control Block)이 생성된다.

쓰레드는 운영체제가 작업을 처리하는 단위이다.

쓰레드 방식을 프로세스 방식보다 안정성이 떨어진다.

프로세스 방식은 하나의 프로세스에 문제가 생기더라도 다른 프로세스에 영향을 주지 않지만 쓰레드 방식인 경우 프로세스에 속한 쓰레드에 영향을 주기 때문이다.

하지만 쓰레드 방식은 프로세스 방식보다 오버헤드가 적고 속도가 빠르다.

각각의 프로세스들은 고유한 자원을 가지고 있고 프로세스끼리 통신하기 위해서는 IPC(Inter-Process Communication)를 해야하기 때문이다.

오버헤드란 프로그램 실행흐름에서 나타나는 현상으로 추가적으로 시간, 메모리, 자원이 사용되는 현상이다.