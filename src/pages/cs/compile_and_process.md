# 컴파일과 프로세스

- 목차
    1. 컴파일이 되는 과정
    

## 컴파일이 되는 과정

프로그래밍 언어는 컴파일 언어와 인터프리터 언어 두가지로 구분이 가능하다.

컴파일 언어는 개발자가 코드를 작성하고 컴파일이라는 과정을 거쳐서 0과 1로 구성된 기계어로 실행파일을 만든다.

컴파일 과정에서 개발자가 문법 오류를 일으켰는지 검사를 하고 CPU에서 처리 가능한 기계어로 실행파일을 만들어 놓기때문에 속도가 빠르다.

C, C++, C# 등이 이에 속한다.

반면 인터프리터 언어는 개발자가 작성한 코드를 미리 기계어로 만들지 않고 실행 시 코드를 한 줄씩 해석해 실행하는 언어이다.

미리 검사를 하지 않기 때문에 실행시 오류가 날 수도 있고 속도도 컴파일 언어와 비교하면 느리다.

Javascript, Python, Ruby 등이 이에 속한다.

한 예로 자바스크립트 v8엔진이라는 구글 크롬에서 사용하는 인터프리터가 있다.

이제 프로세스의 메모리 구조를 다시 살펴보자.

프로세스는 코드영역과 데이터영역, 스택과 힙영역으로 나뉜다.

코드영역은 말 그대로 실행해야 할 코드가 들어가는 영역이고 데이터 영역은 전역변수나 배열이 들어가는 영역이다.

스택과 힙은 프로세스가 실행될 때 할당되는 메모리로 스택에는 지역변수와 함수 관련 값들이 들어가고 힙은 실행중에 메모리 공간을 할당할 수 있는 유동적인 공간이다.

이제 컴파일 언어로 작성된 파일이 어떻게 프로세스가 되는지 알아보자.

개발자가 50과 100을 더하는 간단한 프로그램을 C언어로 작성했다.

![](https://velog.velcdn.com/images/deonii/post/b2547078-a09b-44ba-ae43-d972226df07e/image.png)


10번 줄에 있는 printf() 함수를 이용하기 위해서 2번 줄에 #include 문을 추가했다.

4번 줄에서는 숫자 100을 MY_NUMBER로 치환시켰다.

6번 줄에서 프로그램 실행시 자동으로 실행되는 main함수를 선언했다. 이를 매크로라고 한다.

8번 줄에서 num1이라는 변수를 선언하고 50으로 초기화한다.

10번 줄에서 변수 num1과 매크로인 MY_NUMBER를 더한 값을 화면에 출력하고 프로그램을 종료한다.

이제 프로그램을 다 만들었으니 실행파일로 만들기 위해서 컴파일을 해줘야한다.

개발자가 작성한 코드는 컴파일러를 커쳐서 실행파일이 되는데 컴파일 과정은 다음과 같다.

개발자가 코드를 작성하고 test.c라는 파일로 저장했다.

이제 컴파일러를 실행시키면 가장 먼저 전처리 단계를 밟는다.

전처리기는 test.c파일을 훑어보고 전처리 구문을 처리해준다.

전처리 구문은 #으로 시작하는데 여기서는 #include와 #define이 있다.

전처리기를 통하면 2번 줄의 #include를 통해 stdio.h의 내용이 들어오게되고 4번 줄에서 선언한 매크로 MY_NUMBER 값은 전부 100으로 치환된다.

코드에 있는 모든 주석은 제거된다.

전처리기를 거친 이 파일은 컴파일러가 처리한다.

컴파일러는 c언어로 작성된 이 파일을 기계어에 가까운 어셈블리어로 변환시킨다.

어셈블러를 통해 오브젝트 파일로 변하게된다.

오브젝트 파일은 0과 1로된 기계어로 구성되어있기 때문에 텍스트 에디터에서 열게되면 글씨가 깨지게 된다. 실행에는 문제가 없다.

이 오브젝트 파일에는 코드영역과 데이터영역이 나뉘어져있다.

이 오브젝트 파일이 실행파일이 되기 위해선 링커를 거쳐줘야한다.

지금은 test.c 파일 하나로 프로그램을 만들었지만 복잡한 프로그램에서는 파일이 여러 개가 될 수도 있다.

링커는 이 모든 오브젝트 파일을 하나의 코드영역과 데이터영역으로 묶는다.

그리고 실제로 실행될 주소를 매핑시켜준다.

링커까지 거쳤다면 우리가 흔히보는 exe파일이 생성된다.

이제 이 exe파일은 완벽한 상태의 코드영역과 데이터영역으로 구성되어있다.

사용자가 이 프로그램을 실행시키면 운영체제가 프로세스를 만든다.

운영체제는 exe파일에 있는 코드영역과 데이터영역을 가져와 프로세스의 코드영역과 데이터영역에 넣어주고 빈 상태의 스택과 힙을 할당한다.

그리고 PCB를 만들어 관리가 가능하도록 만들고 프로그램 카운터 즉, 다음 실행할 명령어의 주소를 생성한 프로세스의 코드영역의 첫번째 주소로 설정한다.

그럼 운영체제의 CPU 스케쥴링에 따라서 프로세스가 실행되다가 작업을 마친다.
